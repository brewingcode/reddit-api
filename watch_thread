#!/usr/bin/env python

import api
import sys
import arrow
import time
import websocket
import json
import os
import logging

def ws_watch(thread_id, ws_url):
    logger = logging.getLogger('websocket')
    logger.setLevel(logging.ERROR)
    logger.addHandler(logging.StreamHandler())

    def on_message(ws, message):
        m = json.loads(message)
        if m['type'] == 'update':
            api.live_thread_post(m['payload']['data'])
        elif m['type'] == 'complete':
            print('live thread has been completed, quitting')
            os._exit(0)

    def on_error(ws, err):
        if isinstance(err, KeyboardInterrupt):
            os._exit(0)
        print('websockets error: ', err)

    def on_close(ws):
        watch(thread_id)

    ws = websocket.WebSocketApp(ws_url, on_message=on_message, on_error=on_error,
        on_close=on_close)
    ws.run_forever()

def watch(live_id):
    about = api.api_request('live/'+live_id+'/about').json()['data']
    fmt = '{}\n{} viewers, created {} at https://www.reddit.com/live/{}\n{}\n'
    print(fmt.format(about['title'].encode('utf-8'), about['viewer_count'],
        arrow.get(about['created_utc']).humanize(), about['id'],
        about['description'].encode('utf-8')))
    time.sleep(5)

    posts = api.api_request('live/'+live_id).json()['data']['children']
    while len(posts) > 10:
        posts.pop()
    posts.reverse()
    for post in posts:
        api.live_thread_post(post['data'])
    ws_watch(live_id, about['websocket_url'])

if len(sys.argv) == 2:
    watch(sys.argv[1])
else:
    r = api.api_request('api/live/happening_now')
    if r.status_code == 200:
        watch(r.json()['data']['id'])
    else:
        print("no 'happening now' live thread, pass in the thread ID to watch")
